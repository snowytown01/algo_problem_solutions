import heapq

def solution(food_times, k): #k는 남은시간
    if sum(food_times) <= k:
        return -1
    
    q = []
    for i in range(len(food_times)):
        heapq.heappush(q, (food_times[i], i+1))

    sum_value = 0 #
    previous = 0    #이전의 음식의 초기 음식시간(초기음식시간이란, 입력받을때의 초기숫자 그 숫자 그대로를 의미)
    length = len(food_times)  #현재까지 남은 음식개수

    while sum_value + ((q[0][0] - previous) * length) <= k:
    # 현재상태에서 가장 먹는시간이 적은것의 먹는시간에서 now라는놈의 먹는시간을 빼준다.
    # now라는놈은 현재상태에서 가장 먹는시간이 적은것보다 먹는시간이 적으므로 빼준결과는
    # 현재상태에서 가장 먹는시간이 적은것의 남은먹는시간이 된다. 거기에 현재남은 음식수를 곱해주면
    # 현재상태에서 가장 먹는시간이 적은것 마저 다 먹는데 걸리는 시간이된다. 
    # 그걸 지금까지 먹어온 음식들을 다먹고난뒤의시간인 sum_value에 더해주면 결과는
    # 현재상태에서 가장 먹는시간이 적은것마저 다먹고난뒤의 시간이된다. 그것이 허용된시간k보다 커지면
    # 현재상태에서 가장 먹는시간이 적은것을 먹지않고 while문을 점프하도록하는것
        now = heapq.heappop(q)[0] #가장 먹는시간이 적은 음식의 초기 음식시간
        sum_value += (now-previous) * length #초기음식시간끼리 빼줘야 now라는 놈의음식을 다 먹을때까지 걸리는 시간이나옴
        # 그걸 현재상황에서 남은음식수를 곱하면 그 음식수만큼을 now라는놈의음식을다먹을때걸리는시간을 주기삼아서 반복해주면
        # 그 now라는놈을 다먹을수있음
        # 그걸 sumvalue에 더해주기 sumvalue는 now라는놈을 다먹고나서의 시작시간부터 다먹고난후까지의 시간을 의미
        length -= 1
        previous = now
    
    result = sorted(q, key=lambda x: x[1]) #q를 소팅하는데 그 기준을 q안에 들어가있는정보중 음식의순번으로한다.
    # 주의할점은 현재 q에는 위의 while문을 거쳐서 다먹은 음식은 제거되어있는상태이다.
    return result[(k-sum_value)%length][1]
    # result는 q들의 리스트이다. 허용시간에서 현재상태에서 가장 먹는시간이 적은것을 먹지않고 있는 상태까지 시간인 
    # sum_value를 빼준다. 빼준결과값이 앞으로 남은 허용시간이된다.
    # 그것을 남은 음식의개수로 나누었을때의 나머지로하면 그 나머지는 남은음식들중에서 몇번째를 나타내는지 나타내는 수가된다 
    # 위에서 result를 음식의순번으로 했으므로 나오는것은 남은허용시간만큼 하나씩 앞에서부터 센 q를 반환하고
    # 그 q의 정보중에서 음식의 순번을 반환하도록하면 해답이된다.
    